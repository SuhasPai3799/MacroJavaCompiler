//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
class Range{
  int start;
  int end;
  String gg;  //end point
  String ff; //start point
  String full_name;
}
class SortMe implements Comparator<Range>
{
    public int compare(Range o1, Range o2)
    {
        if(o1.gg.equals(o2.gg))
        return o1.ff.compareTo(o2.ff);
        else
        return o1.gg.compareTo(o2.gg);
    }
}
class SortMeSt implements Comparator<Range>
{
    public int compare(Range o1, Range o2)
    {
        if(o1.ff.equals(o2.ff))
          return o1.gg.compareTo(o2.ff);
        else
        return o1.ff.compareTo(o2.ff);
    }
}
public class Liveness<R> implements GJNoArguVisitor<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   int tot_count = 0;
   boolean ret_flag = false;
   String cur_func = "";
   String curs = "";
   int max_regs = 18;
   int tot_regs = 18;
   int spill_pos = 0;
   boolean move = false;
   boolean [] free_regs = new boolean[max_regs];
   public static HashMap<Integer,Vector> ins = new HashMap<Integer,Vector>();  // ins for nodes
   public static HashMap<Integer,Vector> outs = new HashMap<Integer,Vector>(); // outs for nodes
   public static HashMap<Integer,Vector> use = new HashMap<Integer,Vector>(); // use for nodes
   public static HashMap<Integer,Vector> defs = new HashMap<Integer,Vector>(); // defs for nodes 
   public static Set<Integer> pcs = new HashSet<Integer>();  //pcs 
   public static Set<Integer> rets = new HashSet<Integer>(); //if a pc corresponds to a return st
   public static HashMap<Integer,Vector> child = new HashMap<Integer,Vector>(); // child graph
   public static HashMap<String,Integer> label_pc = new HashMap<String,Integer>(); //mapping a label to a pc
   public static Set<String> all_temps = new HashSet<String>(); //set of all temps
   public static HashMap<String,Range> live_ranges = new HashMap<String,Range>();  //object map, for sorting
   public static Vector active = new Vector();  //active map
   public static Vector all_ranges = new Vector(); //all ranges, needed for reg alloc
   public static HashMap<String,Vector> func_temps = new HashMap<String,Vector>(); //all temps of a func
   public static Set<String> func_names = new HashSet<String>();  // function names
   public static HashMap<String,Integer> alloc_regs = new HashMap<String,Integer>();  // op of register alloc
   public static HashMap<String,Integer> my_args = new HashMap<String,Integer> ();
   public static HashMap<String,Vector> my_calls = new HashMap<String,Vector>();
   public static HashMap<String,Integer> my_maxs = new HashMap<String,Integer>();
   public static HashMap<String,Integer> my_spills = new HashMap<String,Integer>();
   public static HashMap<String,Vector> temp_spills = new HashMap<String,Vector>();
   public static HashMap<String,Integer> func_spills = new HashMap<String,Integer>();


   public R visit(NodeList n) {
      R _ret=(R)"";
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         String gg = (String)_ret;
         gg += (String)e.nextElement().accept(this) + " ";
         _ret = (R)gg;
         _count++;
      }


      return (R)_ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {

          R _ret=(R)"";
         int _count=0;
         boolean flag = true;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            String gg = (String)_ret;
            String wait = (String)e.nextElement().accept(this);
            if(wait == null)
              wait = "";
             gg += wait + " " ;
             String [] br = wait.split(" ");
             if(br.length>0 )
             {
                if(br[0].equals("TEMP"))
                {
                  ;
                }
                else
                  flag=false;
             }
             else
             {
              flag=false;
             }
             _ret = (R)gg;
                _count++;
         }
         try{
         int cur_max = my_maxs.get(curs);
         if(_count>cur_max && flag==true)
         {
          my_maxs.put(curs,_count);
         }
         //debug(_count + "Node list ope");
          }
          catch(Exception e)
          {
            ;
          }
                 return (R)_ret;
      }
      else
         return (R)" ";
   }

   public R visit(NodeOptional n) {
      if ( n.present() )

      { 
        String str = (String)n.node.accept(this);
        label_pc.put(str,tot_count+1);  
        //debug( " " + tot_count+1);
        return (R)str;
      }
      else
         return (R)" ";
   }

   public R visit(NodeSequence n) {
      R _ret=(R)"";
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         String gg = (String)_ret;
         gg += (String)e.nextElement().accept(this) + " ";
         _ret = (R)gg;
         _count++;
      }
      
         //debug(_count + "Node seq ope");
      return (R)_ret;
   }

   public R visit(NodeToken n) { return (R)n.tokenImage; }

   public int max(int a,int b)
   {
    if(a>b)
      return a;
    else
      return b;
   }
   public void debug(String str)
   {
      System.out.println(str);
   }
   public void Stack_Load(int x){
      if(x==0)
      {
        for(int i=0;i<10;i++)
        {
            debug("ALOAD " + "t"+i+" " + "SPILLEDARG " + i );
        }
      }

   }
   public String get_str(int x)
   {
      String res = "";
      for(int i=0;i<x;i++)
      {
        res+="1";
      }
      return res;
   }
   public Vector UnionVec(Vector v1,Vector v2)
   {
      Vector res = new Vector();
      for(int i=0;i<v1.size();i++)
      {
         if(res.contains(v1.get(i)))
         {
           ;
         }
         else
         {
            res.add(v1.get(i));
         }
      }
      for(int i=0;i<v2.size();i++)
      {
        if(res.contains(v2.get(i)))
        {
          ;
        }
        else
        {
            res.add(v2.get(i));
        }
      }
      return res;
   }
   public Vector DiffVec(Vector v1,Vector v2)
   {
      Vector res = new Vector();
      for(int i=0;i<v1.size();i++)
      {
          if(v2.contains(v1.get(i)))
            continue;
          else
            res.add(v1.get(i));
      }
      return res; 
   }
   public void calc()
   {
      //debug(tot_count + "");
      int prev_sum = 0;
      int ctr =0;
      while(true)
      {
        ctr++;
        int cur_sum =0;
        for(int i=1;i<=tot_count;i++)
        {
            if(rets.contains(i))
            {
                Vector cur_out = new Vector();
                Vector gg = (Vector)child.get(i);
                //debug(gg.size() + "");
                
                Vector sym = DiffVec(outs.get(i),(Vector)defs.get(i));
                Vector cur_in  = new Vector();
                try{
                cur_in = UnionVec((Vector)(use.get(i)),sym);
                }
                catch(Exception e)
                {
                  debug(i + "asdasd");
                }
                ins.put(i,cur_in);
                outs.put(i,cur_out);
                cur_sum+=cur_in.size();
                cur_sum+=cur_out.size();
            }
            else
            {
                Vector cur_out = new Vector();
                Vector gg = (Vector)child.get(i);
                //debug(gg.size() + "");
                for(int j=0;j<gg.size();j++)
                {
                    if((int)gg.get(j) <= tot_count)
                    {
                    try{
                    cur_out = UnionVec(cur_out,(Vector)(ins.get((gg.get(j)))));
                    }
                    catch(Exception e)
                    {
                      debug(gg.get(j) + "$$$" + tot_count);
                    }
                    }
                    //debug(cur_out.size() + "");
                }
                Vector sym = DiffVec(outs.get(i),(Vector)defs.get(i));
                Vector cur_in = UnionVec((Vector)(use.get(i)),sym);
                ins.put(i,cur_in);
                outs.put(i,cur_out);
                cur_sum+=cur_in.size();
                cur_sum+=cur_out.size();
            }
        }
        if(cur_sum==prev_sum)
          break;
        else
          prev_sum=cur_sum;
      }
      //debug(ctr+"$$$$$$$$");
      //debug(all_temps.size());
      for(String s : all_temps)
      {
          int st = 1;
          int end = 1;
          for(int i=1;i<=tot_count;i++)
          {
            if(defs.get(i).contains(s) )  // check
            {
              st = i;
              break;
            }
          }
          for(int i=1;i<=tot_count;i++)
          {
            if(outs.get(i).contains(s) || defs.get(i).contains(s))
            {
              end=i;
            }
          }
          //debug(s + " Starts at " + st + " Ends at " + end);
          Range  obj = new Range();
          obj.start= st;
          obj.end = end;
          obj.ff = get_str(st);
          obj.gg = get_str(end);
          obj.full_name = s;
          live_ranges.put(s,obj);
          String [] lol = s.split(" ");
          func_temps.get(lol[0]).add(obj);

      }
      
      for(String s:func_names)
      {
        LinScanRegAlloc(func_temps.get(s));
        Vector v = func_temps.get(s);
        for(int i=0;i<v.size();i++)
        {
          //debug(alloc_regs.get(((Range)v.get(i)).full_name) + " " + ((Range)v.get(i)).full_name );
          ;
        }
        
      }
   }
   public void Expire(int x)
   {
        Vector rems = new Vector();
        boolean [] rem = new boolean [active.size()];
        Comparator<Range> comparator = new SortMe();
        Collections.sort(active,comparator);
        // debug("###");
        // for(int i=0;i<active.size();i++)
        // {
        //   debug(((Range)active.get(i)).end + "");
        // }
        for(int i=0;i<active.size();i++)
        {
          //debug(((Range)active.get(i)).end + " ------ " +  ((Range)all_ranges.get(x)).start);

          if(((Range)active.get(i)).end>= ((Range)all_ranges.get(x)).start)
          {
             break;
          } 
          else
          {
            rems.add(i);
            rem[i]=true;
          }
        }
        //debug(rems.size() + " ");
        for(int i=0;i<rems.size();i++)
        {
          //active.remove(rems.get(i));
          //debug(((Range)active.get(i)).full_name);
          free_regs[alloc_regs.get((((Range)active.get(i)).full_name))]=false;
        }
        // if(active.size() == 18)
        // {
        //   debug(((Range)active.get(0)).end + "     -----     " + ((Range)all_ranges.get(x)).start);
        // }
        
        //active.clear();
        Vector active1 = new Vector();
        for(int i=0;i<rem.length;i++)
        {
          if(rem[i]==false)
          {
            active1.add(active.get(i));
          }
        }
        active.clear();
        for(int i=0;i<active1.size();i++)
        {
          active.add(active1.get(i));
        }
        //debug(active.size() + "");
        
        Collections.sort(active,comparator);
   }
   public void SpillAtInter(int x)
   {
        Comparator<Range> comparator = new SortMe();
        Collections.sort(active,comparator);
        if(active.size()>0)
        {
            Range last = (Range)(active.get(active.size()-1));
            Range obj = (Range)(all_ranges.get(x));
            if(last.end>obj.end)
            {
                int reg = alloc_regs.get(last.full_name);
                alloc_regs.put(obj.full_name,reg);
                alloc_regs.put(last.full_name,-1);
                my_spills.put(last.full_name,spill_pos);
                spill_pos++;
                func_spills.put(curs,spill_pos);
                temp_spills.get(curs).add(last.full_name);
                active.remove(active.size()-1);
                active.add(obj);

            }
            else
            {
                alloc_regs.put(last.full_name,-1);
                my_spills.put(last.full_name,spill_pos);
                spill_pos++;
                func_spills.put(curs,spill_pos);
                temp_spills.get(curs).add(last.full_name);
            }
        }
   }
   public void LinScanRegAlloc(Vector func_ranges)
   {
      //Vector active = new Vector();
      //boolean[] free_regs =  new boolean[tot_regs];
      all_ranges.clear();
      active.clear();
      for(int i=0;i<func_ranges.size();i++)
      {
        all_ranges.add(func_ranges.get(i));
      }
      Comparator<Range> comparator1 = new SortMeSt();
      Collections.sort(all_ranges,comparator1);
      // for(int i=0;i<all_ranges.size();i++)
      // {
      //    debug(((Range)all_ranges.get(i)).start + " ----- " + ((Range)all_ranges.get(i)).end + "        " + ((Range)all_ranges.get(i)).full_name);

      // }
      for(int i=0;i<tot_regs;i++)
      {
        free_regs[i]=false;
      }

      for(int i=0;i<all_ranges.size();i++)
      {
        Expire(i);

        if(active.size()==18)
        {
          SpillAtInter(i);
        }
        else
        {
           int alloc = -1;
           for(int j = 0;j<tot_regs;j++)
           {
              if(free_regs[j]==false)
              {
                alloc=j;
                free_regs[j]=true;
                break;
              }
           }
           alloc_regs.put(((Range)all_ranges.get(i)).full_name,alloc);
           active.add(all_ranges.get(i));
           Comparator<Range> comparator = new SortMe();
           Collections.sort(active,comparator);
          
        }
      }
   }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n) {
      R _ret=null;
      n.f0.accept(this);
      //cur_func = "MAIN";
      //funcs.add("MAIN");
      //funcs_ranges.put("MAIN",new Vector());
      cur_func = "MAIN ";
      curs = "MAIN";
      func_names.add("MAIN");
      my_args.put("MAIN",0);
      my_calls.put("MAIN",new Vector());
      my_maxs.put("MAIN",0);
      func_temps.put("MAIN",new Vector());
      func_spills.put("MAIN",0);
      spill_pos = 0;
      temp_spills.put("MAIN",new Vector());
      n.f1.accept(this);
      //cur_func = "";
      n.f2.accept(this);
      calc();
      pcs.clear();
      all_temps.clear();
      func_names.clear();
      use.clear();
      defs.clear();
      ins.clear();
      outs.clear();
      child.clear();
      rets.clear();
      n.f3.accept(this);
      //debug("Hello" + tot_count);
      
      n.f4.accept(this);
      
      //debug(tot_count + "");

      // for(String s:temp_names)
      // {
      //   Vector v = live_ranges.get(s);
      //   String str = s + "  " ;
      //   for(int i=0;i<v.size();i++)
      //   {
      //     str+=((Range)v.get(i)).start + " ----- " + ((Range)v.get(i)).end + "        ";
      //     all_ranges.add(v.get(i));
      //   }
      //   debug(str);
      // }
      //debug("###################################################");
      
      // for(String fun:funcs){
      //   Comparator<Range> comparator1 = new SortMeSt();
      //  Collections.sort(funcs_ranges.get(fun),comparator1);
      //   LinScanRegAlloc((Vector)funcs_ranges.get(fun));
      // }
      // for(String s:temp_names)
      // {
      //   Vector v = live_ranges.get(s);
      //   String str = s + "  " ;
      //   for(int i=0;i<v.size();i++)
      //   {
      //     debug(""+alloc_regs.get(((Range)v.get(i)).full_name) + " " + ((Range)v.get(i)).full_name + " starts at " + ((Range)v.get(i)).start + " ends at " + ((Range)v.get(i)).end );
      //   }
        
      // }
      
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n) {
      R _ret=null;
      
      String gg = (String)n.f0.accept(this);
      func_names.add(gg);
      func_temps.put(gg,new Vector());
      cur_func = gg + " ";
      curs = gg;
      my_calls.put(gg,new Vector());
      my_maxs.put(gg,0);
      temp_spills.put(gg,new Vector());
      func_spills.put(gg,0);
      spill_pos = 0;
      String str = (String)n.f2.accept(this);
      my_args.put(gg,Integer.parseInt(str));
      tot_count = 0;
      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector());
        child.get(tot_count).add(tot_count+1);
        for(int i=0;i<Integer.parseInt(str);i++)
        {
          defs.get(tot_count).add(cur_func + "TEMP " + i);
          all_temps.add(cur_func + "TEMP " + i); 
          //debug("Hello");
        }
        
      }
      n.f3.accept(this);
      n.f4.accept(this);
      calc();
      tot_count = 0;
      pcs.clear();
      all_temps.clear();
      func_names.clear();
      use.clear();
      defs.clear();
      ins.clear();
      outs.clear();
      child.clear();
      rets.clear();
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n) {
      R _ret=null;
      n.f0.accept(this);

      return (R)_ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n) {
      R _ret=null;
      n.f0.accept(this);

      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector());
        child.get(tot_count).add(tot_count+1);

      }


      return (R)"NOOP";
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n) {
      R _ret=null;
      n.f0.accept(this);
      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector());
        child.get(tot_count).add(tot_count+1);
        
      }
      return (R)"ERROR";
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n) {
      R _ret=null;
      String t1 = "CJUMP";
      String t2 = (String)n.f1.accept(this);
      String t3 = (String)n.f2.accept(this);
      String res = t1 +  " " + t2 + " " + t3;
      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector());
        child.get(tot_count).add(tot_count+1);
        int findl = LabelMap.label_pc.get(curs+"1234"+t3);
        child.get(tot_count).add(findl);
        use.get(tot_count).add(cur_func + t2);
        //debug("Added " + findl);
      }
      return (R)res;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n) {
      R _ret=null;
      String t1 = "JUMP";
      String t2 = (String)n.f1.accept(this);
      String res= t1 + " " + t2;
      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector()); 
        int findl = LabelMap.label_pc.get(curs+"1234"+t2);
        child.get(tot_count).add(findl);
        //debug("Added " + findl);
      }
      return (R)res;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n) {
      R _ret=null;
      String t1 = "HSTORE";
      String t2 = (String)n.f1.accept(this);
      String t3 = (String)n.f2.accept(this);
      String t4 = (String)n.f3.accept(this); 
      String res = t1 +  " " + t2 + " " + t3 + " " + t4;
      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector()); 
        child.get(tot_count).add(tot_count+1);
        use.get(tot_count).add(cur_func+t2);
        use.get(tot_count).add(cur_func+t4);
      }
      return (R)res;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n) {
      R _ret=null;
      String t1 = "HLOAD";
      String t2 = (String)n.f1.accept(this);
      String t3 = (String)n.f2.accept(this);
      String t4 = (String)n.f3.accept(this); 
      String res = t1 +  " " + t2 + " " + t3 + " " + t4;
      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector()); 
        child.get(tot_count).add(tot_count+1);
        defs.get(tot_count).add(cur_func+t2);
        use.get(tot_count).add(cur_func+t3);

      }
      return (R)res;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n) {
      R _ret=null;
      String t1 =  "MOVE";
      move = true;
      String t2 = (String)n.f1.accept(this);
      String t3 = (String)n.f2.accept(this);
      String res = t1 +  " " + t2 + " " + t3;
      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector());
        child.get(tot_count).add(tot_count+1);
        defs.get(tot_count).add(cur_func + t2);
        String [] alls = t3.split(" ");
        for(int i=0;i<alls.length-1;i++)
        {

          if(alls[i].equals("TEMP") || alls[i].equals("TEMP ") || alls[i].equals(" TEMP"))
          {
            use.get(tot_count).add(cur_func + "TEMP" + " " + alls[i+1]);
            //debug("TEMP" + alls[i+1]);
              //debug("helokoasd" + tot_count);
          }
        }
      }
      return (R)res;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n) {
      R _ret=null;
      String t1 =  "PRINT";
      String t2 = (String)n.f1.accept(this);
      String res= t1 + " " + t2;
      if(pcs.contains(tot_count+1))
      {
        ;
      }
      else
      {
        pcs.add(tot_count+1);
        tot_count++;
        child.put(tot_count,new Vector());
        ins.put(tot_count,new Vector());
        outs.put(tot_count,new Vector());
        defs.put(tot_count,new Vector());
        use.put(tot_count,new Vector());
        child.get(tot_count).add(tot_count+1);
        String [] alls = t2.split(" ");
        for(int i=0;i<alls.length-1;i++)
        {
          if(alls[i].equals("TEMP") || alls[i].equals("TEMP ") || alls[i].equals(" TEMP"))
          use.get(tot_count).add(cur_func+"TEMP " + alls[i+1]);
        }

      }
      return (R)res;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n) {
      R _ret=null;
      String t1 = (String)n.f0.accept(this);
      return (R)t1;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n) {
      R _ret=null;
      String t1 =  "BEGIN";
      String t2 = (String)n.f1.accept(this);
      String t3 = (String)n.f2.accept(this);
      ret_flag = true;
      String t4 = (String)n.f3.accept(this);
      ret_flag = false;
      String t5 = "END";
      String res = t1 + " " + t2 + " " + t3 + " " + t4 + " " + t5;
      return (R)res;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n) {
      R _ret=null;
      String t1 = "CALL";
      String t2 = (String)n.f1.accept(this);
      String t3 = (String)n.f2.accept(this);
      String t4 = (String)n.f3.accept(this);
      String t5 = (String)n.f4.accept(this);
      String res = t1 + " " + t2 + " " + t3 + " " + t4 + " " + t5;
      return (R)res;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n) {
      R _ret=null;
      String t1 = "HALLOCATE";
      String t2 = (String)n.f1.accept(this);
      String res = t1 + " " + t2;
      return (R)res;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n) {
      R _ret=null;
      String t1 = (String)n.f0.accept(this);
      String t2 = (String)n.f1.accept(this);
      String t3 = (String)n.f2.accept(this);
      String res = t1 + " " + t2 + " " + t3 ;
      return (R)res;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n) {
      R _ret=null;
      String res = (String)n.f0.accept(this);
      //debug("OP  " + res);  
      return (R)res;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n) {
      R _ret=null;
      String res = (String)n.f0.accept(this);
      String [] spl = res.split(" ");
      if(ret_flag==true)
      {
        if(pcs.contains(tot_count+1))
        {
          ;
        }
        else
        {
            pcs.add(tot_count+1);
            rets.add(tot_count+1);
            tot_count++;
            child.put(tot_count,new Vector());
            ins.put(tot_count,new Vector());
            outs.put(tot_count,new Vector());
            defs.put(tot_count,new Vector());
            use.put(tot_count,new Vector()); 
            String [] alls = res.split(" ");
            for(int i=0;i<alls.length-1;i++)
            {
              if(alls[i].equals("TEMP"))
              use.get(tot_count).add(cur_func+"TEMP " + alls[i+1]);
            }

        }
        ret_flag = false;
      }
      return (R)res;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n) {
      R _ret=null;
      String gg = "TEMP";

      String gg1 = (String)n.f1.accept(this);
      all_temps.add(cur_func+gg + " " + gg1);
      return (R)(gg + " " + gg1);
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      
      return (R)n.f0.accept(this);
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n) {
      R _ret=null;
      n.f0.accept(this);
      if(move==true && n.f0.tokenImage.contains("_"))
      {
        my_calls.get(curs).add(n.f0.tokenImage);
      }
      //debug(n.f0.tokenImage);
      return (R)n.f0.tokenImage;
   }

}
